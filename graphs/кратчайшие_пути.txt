Кратчайший путь между двумя вершинами в графе - это путь с минимальной
суммой весов рёбер.
Алгоритмы:
1. Дейкстры
2. Белмона - Форда
3. Флойда - Уоршелла
4. Алгоритм Джонсона (Алгоритм A*)
Взвешаный граф:
о    Содержит дополнительную информацию - вес каждого ребра.
     Этот вес может представлять расстояние между двумя точками, стоимость
     перехода от одной точки к другой, время, затраченное на перемещение,
     и так далее.
о    Вес ребра в графе - это численное значение, которое отображает
     "стоимость" перехода от одной вершины к другой.

Ориентированный граф(диграф)
о    В ориентированном графе рёбра имеют направление. Это означает,
     что движение возможно только в указанном направлении.
о    Например, если есть ребро из вершины А к вершине В, это не гара-
     нтирует, что существует путь из В в А.


Алгоритм Дейкстры
о    Находит кратчайший путь от одной заданной вершины до всех остальных
     вершин в графе.
о    Он работает только с графами, в которых все веса рёбер неотрицательны.
     Алгоритм работает путём последовательного "расслабления" рёбер графа
     "Расслабление" ребра в данном контексте означает процесс улучшения
     текущей оценки кратчайшего пути.

Алгоритм Беллмана - Форда
о    Находит кратчайшие пути от одной вершины до всех остальных, но он
     может работать и с отрицательными весами рёбер.
о    В графах, содержащих циклы отрицательного веса, не существует опре-
    деления "кратчайшего пути". Алгоритм Беллмана - Форда также расслабляет
    рёбра, но делает это V - 1 раз, где V - количество вершин в графе.
Это гарантирует, что мы получим кратчайший путь даже в случае наличия
отрицательных весов при условии, что в графе нет циклов отрицательного веса.

Объянение phind что такое цикл отрицательного веса.
Представьте, что у вас есть карта города, где каждый перекресток (вершина)
связан с другими перекрестками (вершинами) дорогами (рёбрами). Каждая
дорога имеет свой вес, который показывает, сколько времени займет проезд
от одного перекрестка до другого.

Цикл отрицательного веса - это ситуация, когда вы можете обойти некоторый
путь в городе и вернуться обратно, но при этом общее время проезда будет
меньше, чем если бы вы просто шли прямой. Это происходит, когда вес не-
которых дорог отрицательный.

Алгоритм Флойда - Уоршелла
    Находит кратчайшие пути между всеми парами вершин и может работать с гра-
фами, в которых веса рёбер могут быть и положительными и отрицательными.
    Алгоритм состоит из 3 вложенных циклов, которые последовательно рас-
сматривают все вершины графа как возможные промежуточные точки на пути от од-
ной вершины к другой. Этот алгоритм позволяет нам получить кратчайшие пути между
всеми парами вершин. Однако так же, как и в случае алгоритма Беллмана - Форда,
в графе не должно быть циклов отрицательного веса.

Алгоритм Джонсона
Подходит для поиска кратчайших путей в графах с отрицательными весами.

Алгоритм А*
Используется в области исскуственного интелекта для поиска пути в пространстве
с множеством состояний.

BFS(поиск в ширину) и поиск кратчайших путей
o    BFS идеально подходит для поиска кратчайшего пути в невзвешенном графе, где
"кратчайший" означает путь с наименьшим количеством рёбер.
o    BFS работает, обрабатывая вершины в графе по уровням, начиная от исходной 
вершины
о    BFS не учитывает веса рёбер, так что этот подход не будет работать во взвешанных
графах.

DFS (Поиск в глубину)
о    Не используется для поиска кратчайших путей:
он будет глубоко проникать в граф, следуя каждому пути до конца, прежде чем пере-
йти к следующему пути.
о    DFS может "пропустить" более короткий путь, который был бы доступен,
если бы он выбрал другой путь для следования.

Реализуем сначала класс граф, а затем алгоритмы поиска.

Как работает алгоритм Дейкстры:
     У нас есть очередь с приоритетом и словарь расстояний до всех вершин от да-
     нной (в том числе и до неё самой же). Далее мы выбираем вершину с наимень-
     шим расстоянием из очереди с приоритетом(буду называть её очп, в начале в 
     ней лежит сама вершина старта), пока очп не пуста, будем доставать из неё
     вершины, будем перебирать всех соседей этих вершин, если для какой-то
     мы сможем улучшить расстояние(расслабление рёбер), то закидываем её в очп.
     Можно доказать по индукции(вести индукцию необхдимо по количеству рёбер в
     минимальных путях(допустим мы найдём все минимальные пути длинной n - 
     рёбер, тогда мы найдём и длинной n + 1)), что таким образом мы гарантиро-
     ванной найдём расстояние от данной вершины до всех, либо докажем, что пу-
     тей нет.

Основным преимуществом алгоритма Белмана - Форда является то, что он по-
зволяет обнаруживать циклы отрицательной величины в графе.

Как работает Беллман-Форд:
Мы перебираем все вершины, смотрим рёбра из них выходящие, если мы можем
"расслабить" рёбра - делаем, так v - 1 раз. Очевидно, что все минимальные
пути мы отыскали, ведь за k итераций мы находим все минимальные пути длинной k.
Далее запускаем процесс, если можем ещё раз "расслабить" рёбра, то в графе
есть цикл отрицательного веса.

Как работает алгоритм Флойда - Уоршелла:
По-моему ничего нового, если зафиксировать k и i то же самое(исходить
из предположения, что все )



